"use strict";(self.webpackChunksmartts_sdk_docs=self.webpackChunksmartts_sdk_docs||[]).push([[460],{3905:function(e,t,a){a.d(t,{Zo:function(){return u},kt:function(){return m}});var n=a(7294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var p=n.createContext({}),o=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},u=function(e){var t=o(e.components);return n.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,r=e.originalType,p=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=o(a),m=l,k=d["".concat(p,".").concat(m)]||d[m]||c[m]||r;return a?n.createElement(k,s(s({ref:t},u),{},{components:a})):n.createElement(k,s({ref:t},u))}));function m(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=a.length,s=new Array(r);s[0]=d;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i.mdxType="string"==typeof e?e:l,s[1]=i;for(var o=2;o<r;o++)s[o]=a[o];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},3532:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return i},contentTitle:function(){return p},metadata:function(){return o},toc:function(){return u},default:function(){return d}});var n=a(7462),l=a(3366),r=(a(7294),a(3905)),s=["components"],i={},p="Types",o={unversionedId:"types",id:"types",title:"Types",description:"Singleton Types",source:"@site/docs/types.md",sourceDirName:".",slug:"/types",permalink:"/smartts-sdk/types",editUrl:"https://github.com/RomarQ/smartts-sdk/tree/main/documentation/docs/types.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Literal Expressions",permalink:"/smartts-sdk/literals"},next:{title:"Arithmetic",permalink:"/smartts-sdk/expressions/arithmetic"}},u=[{value:"Singleton Types",id:"singleton-types",children:[{value:"nat",id:"nat",children:[],level:3},{value:"int",id:"int",children:[],level:3},{value:"mutez",id:"mutez",children:[],level:3},{value:"string",id:"string",children:[],level:3},{value:"bool",id:"bool",children:[],level:3},{value:"bytes",id:"bytes",children:[],level:3},{value:"address",id:"address",children:[],level:3},{value:"timestamp",id:"timestamp",children:[],level:3},{value:"chain_id",id:"chain_id",children:[],level:3},{value:"bls12_381_fr",id:"bls12_381_fr",children:[],level:3},{value:"bls12_381_g1",id:"bls12_381_g1",children:[],level:3},{value:"bls12_381_g2",id:"bls12_381_g2",children:[],level:3},{value:"key",id:"key",children:[],level:3},{value:"key_hash",id:"key_hash",children:[],level:3},{value:"signature",id:"signature",children:[],level:3},{value:"unit",id:"unit",children:[],level:3},{value:"operation",id:"operation",children:[],level:3},{value:"never",id:"never",children:[],level:3}],level:2},{value:"Container types",id:"container-types",children:[{value:"list",id:"list",children:[],level:3},{value:"set",id:"set",children:[],level:3},{value:"option",id:"option",children:[],level:3},{value:"pair",id:"pair",children:[],level:3},{value:"or",id:"or",children:[],level:3},{value:"map",id:"map",children:[],level:3},{value:"big_map",id:"big_map",children:[],level:3},{value:"lambda",id:"lambda",children:[],level:3},{value:"ticket",id:"ticket",children:[],level:3},{value:"contract",id:"contract",children:[],level:3},{value:"sapling_state",id:"sapling_state",children:[],level:3},{value:"sapling_transaction",id:"sapling_transaction",children:[],level:3}],level:2},{value:"Artificial types",id:"artificial-types",children:[{value:"record",id:"record",children:[],level:3},{value:"variant",id:"variant",children:[],level:3}],level:2}],c={toc:u};function d(e){var t=e.components,a=(0,l.Z)(e,s);return(0,r.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"types"},"Types"),(0,r.kt)("h2",{id:"singleton-types"},"Singleton Types"),(0,r.kt)("h3",{id:"nat"},"nat"),(0,r.kt)("p",null,"Naturals are arbitrary-precision, meaning that the only size limit is gas."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TNat } = require('@tezwell/smartts-sdk');\n\nconst type = TNat();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#nat"},"Value Example"))),(0,r.kt)("h3",{id:"int"},"int"),(0,r.kt)("p",null,"Integers are arbitrary-precision, meaning that the only size limit is gas."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TInt } = require('@tezwell/smartts-sdk');\n\nconst type = TInt();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#int"},"Value Example"))),(0,r.kt)("h3",{id:"mutez"},"mutez"),(0,r.kt)("p",null,"Mutez (micro-Tez) are internally represented by ",(0,r.kt)("strong",{parentName:"p"},"64-bit")," signed integers. These are restricted to prevent creating a negative amount of mutez."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TMutez } = require('@tezwell/smartts-sdk');\n\nconst type = TMutez();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#mutez"},"Value Example"))),(0,r.kt)("h3",{id:"string"},"string"),(0,r.kt)("p",null,"The current version of Michelson restricts strings to be the printable subset of ",(0,r.kt)("strong",{parentName:"p"},"7-bit ASCII"),", namely characters with codes from within ","[32, 126]"," range, plus the following escape characters ",(0,r.kt)("inlineCode",{parentName:"p"},"\\n"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"\\\\"),", ",(0,r.kt)("inlineCode",{parentName:"p"},'\\"'),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TString } = require('@tezwell/smartts-sdk');\n\nconst type = TString();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#string"},"Value Example"))),(0,r.kt)("h3",{id:"bool"},"bool"),(0,r.kt)("p",null,"The type for booleans whose values are ",(0,r.kt)("inlineCode",{parentName:"p"},"True")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"False"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TBool } = require('@tezwell/smartts-sdk');\n\nconst type = TBool();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#bool"},"Value Example"))),(0,r.kt)("h3",{id:"bytes"},"bytes"),(0,r.kt)("p",null,"Bytes are used for serializing data, in order to check signatures and compute hashes on them. They can also be used to incorporate data from the wild and untyped outside world."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TBytes } = require('@tezwell/smartts-sdk');\n\nconst type = TBytes();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#bytes"},"Value Example"))),(0,r.kt)("h3",{id:"address"},"address"),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"address")," gives the guarantee that the value has the form of a Tezos address, as opposed to contract that guarantees that the value is indeed a valid, existing account."),(0,r.kt)("p",null,"A valid Tezos address is a string prefixed by either ",(0,r.kt)("inlineCode",{parentName:"p"},"tz1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"tz2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"tz3")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"KT1")," and followed by a Base58 encoded hash and terminated by a 4-byte checksum."),(0,r.kt)("p",null,"The prefix designates the type of address:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"tz1"))," addresses are followed by a ed25519 public key hash"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"tz2"))," addresses are followed by a Secp256k1 public key hash"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"tz3"))," addresses are followed by a NIST p256r1 public key hash"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"KT1"))," addresses are followed by a contract hash")),(0,r.kt)("p",null,"Addresses prefixed by tz1, tz2 and tz3 designate implicit accounts, whereas those prefixed KT1 designate originated accounts."),(0,r.kt)("p",null,"Addresses can also specify an entrypoint, with a ",(0,r.kt)("inlineCode",{parentName:"p"},"%<entrypoint_name>")," suffix."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TAddress } = require('@tezwell/smartts-sdk');\n\nconst type = TAddress();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#address"},"Value Example"))),(0,r.kt)("h3",{id:"timestamp"},"timestamp"),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"timestamp")," is used to represent timestamps that are written as the number of seconds since Epoch."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TTimestamp } = require('@tezwell/smartts-sdk');\n\nconst type = TTimestamp();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#timestamp"},"Value Example"))),(0,r.kt)("h3",{id:"chain_id"},"chain_id"),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"chain_id")," represents an identifier for a chain, used to distinguish the test and the main chains."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TChain_id } = require('@tezwell/smartts-sdk');\n\nconst type = TChain_id();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#chain_id"},"Value Example"))),(0,r.kt)("h3",{id:"bls12_381_fr"},"bls12_381_fr"),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"bls12_381_fr")," represents an element of the scalar field Fr, used for scalar multiplication on the BLS12-381 curves G1 and G2."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TBls12_381_fr } = require('@tezwell/smartts-sdk');\n\nconst type = TBls12_381_fr();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#bls12_381_fr"},"Value Example"))),(0,r.kt)("h3",{id:"bls12_381_g1"},"bls12_381_g1"),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"bls12_381_g1")," represents a point on the BLS12-381 curve G1."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TBls12_381_g1 } = require('@tezwell/smartts-sdk');\n\nconst type = TBls12_381_g1();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#bls12_381_g1"},"Value Example"))),(0,r.kt)("h3",{id:"bls12_381_g2"},"bls12_381_g2"),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"bls12_381_g2")," represents a point on the BLS12-381 curve G2."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TBls12_381_g2 } = require('@tezwell/smartts-sdk');\n\nconst type = TBls12_381_g2();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#bls12_381_g2"},"Value Example"))),(0,r.kt)("h3",{id:"key"},"key"),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"key")," represents a public cryptographic key."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TKey } = require('@tezwell/smartts-sdk');\n\nconst type = TKey();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#key"},"Value Example"))),(0,r.kt)("h3",{id:"key_hash"},"key_hash"),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"key_hash")," represents a hash of a public cryptographic key."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TKey_hash } = require('@tezwell/smartts-sdk');\n\nconst type = TKey_hash();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#key_hash"},"Value Example"))),(0,r.kt)("h3",{id:"signature"},"signature"),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"signature")," represents a cryptographic signature."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TSignature } = require('@tezwell/smartts-sdk');\n\nconst type = TSignature();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#signature"},"Value Example"))),(0,r.kt)("h3",{id:"unit"},"unit"),(0,r.kt)("p",null,"The type whose only value is Unit, to use as a placeholder when some result or parameter is non-necessary."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TUnit } = require('@tezwell/smartts-sdk');\n\nconst type = TUnit();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#unit"},"Value Example"))),(0,r.kt)("h3",{id:"operation"},"operation"),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"operation")," represents an internal operation emitted by a contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TOperation } = require('@tezwell/smartts-sdk');\n\nconst type = TOperation();\n")),(0,r.kt)("h3",{id:"never"},"never"),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"never")," is used to represent an unreachable branch."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TNever } = require('@tezwell/smartts-sdk');\n\nconst type = TNever();\n")),(0,r.kt)("h2",{id:"container-types"},"Container types"),(0,r.kt)("h3",{id:"list"},"list"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"list")," type reprensents a immutable and homogeneous linked list."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TList, TNat } = require('@tezwell/smartts-sdk');\n\nconst type = TList(TNat());\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#list"},"Value Example"))),(0,r.kt)("h3",{id:"set"},"set"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"set")," type is used to represent sequences of unique elements."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TSet, TNat } = require('@tezwell/smartts-sdk');\n\nconst type = TSet(TNat());\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#set"},"Value Example"))),(0,r.kt)("h3",{id:"option"},"option"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"option")," type is used to represent an optional value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TOption, TNat } = require('@tezwell/smartts-sdk');\n\nconst type = TOption(TNat());\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#some"},"Value Example (Some)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#none"},"Value Example (None)"))),(0,r.kt)("h3",{id:"pair"},"pair"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"pair")," type represents a binary tuple composed of a left element and a right element."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TPair, TNat, TString } = require('@tezwell/smartts-sdk');\n\nconst type = TPair(TString(), TNat());\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#pair"},"Value Example"))),(0,r.kt)("h3",{id:"or"},"or"),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"or")," represents a union of two types. Used for type variance. (e.g. number | string)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TOr, TNat, TString } = require('@tezwell/smartts-sdk');\n\nconst type = TOr(TString(), TNat());\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#left"},"Value Example (Left)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./literals#right"},"Value Example (Right)"))),(0,r.kt)("h3",{id:"map"},"map"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TMap, TNat, TString } = require('@tezwell/smartts-sdk');\n\nconst type = TMap(TString(), TNat());\n")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"./literals#map"},"Value Example")),(0,r.kt)("h3",{id:"big_map"},"big_map"),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"big_map")," is used to represent lazily deserialized maps."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TBigMap, TNat, TString } = require('@tezwell/smartts-sdk');\n\nconst type = TBigMap(TString(), TNat());\n")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"./literals#big_map"},"Value Example")),(0,r.kt)("h3",{id:"lambda"},"lambda"),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"lambda")," represents a function signature."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TLambda, TNat, TString } = require('@tezwell/smartts-sdk');\n\nconst type = TLambda(TString(), TNat());\n")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"./literals#lambda"},"Value Example")),(0,r.kt)("h3",{id:"ticket"},"ticket"),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"ticket")," represents a ticket used to authenticate information."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TTicket, TString } = require('@tezwell/smartts-sdk');\n\nconst type = TTicket(TString());\n")),(0,r.kt)("h3",{id:"contract"},"contract"),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"contract")," represents the interface and address of a contract entrypoint."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TContract, TString } = require('@tezwell/smartts-sdk');\n\nconst type = TContract(TString());\n")),(0,r.kt)("h3",{id:"sapling_state"},"sapling_state"),(0,r.kt)("p",null,"Michelson reference ",(0,r.kt)("a",{parentName:"p",href:"https://tezos.gitlab.io/michelson-reference/#type-sapling_state"},"sapling_state"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TSapling_state } = require('@tezwell/smartts-sdk');\n\nconst type = TSapling_state(8);\n")),(0,r.kt)("h3",{id:"sapling_transaction"},"sapling_transaction"),(0,r.kt)("p",null,"Michelson reference ",(0,r.kt)("a",{parentName:"p",href:"https://tezos.gitlab.io/michelson-reference/#type-sapling_transaction"},"sapling_transaction"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { TSapling_transaction } = require('@tezwell/smartts-sdk');\n\nconst type = TSapling_transaction(8);\n")),(0,r.kt)("h2",{id:"artificial-types"},"Artificial types"),(0,r.kt)("h3",{id:"record"},"record"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"TRecord")," is an artificial type composed of nested ",(0,r.kt)("inlineCode",{parentName:"p"},"pair's")," with annotated leaves to simulate a dictionary."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const { TRecord, TNat, TInt, TBytes } = require(\'@tezwell/smartts-sdk\');\n\nconst type = TRecord(\n    {\n        field1: TNat(),\n        field2: TInt(),\n        field3: TBytes()\n    },\n    // Optional argument (defaults to right combs)\n    ["field1", ["field2", "field3"]]\n);\n')),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"./literals#record"},"Value Example")),(0,r.kt)("h3",{id:"variant"},"variant"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"TVariant")," is an artificial type composed of nested ",(0,r.kt)("inlineCode",{parentName:"p"},"or's")," with annotated leaves to create a union type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const { TVariant, TNat, TInt, TBytes } = require(\'@tezwell/smartts-sdk\');\n\nconst type = TVariant(\n    {\n        branch1: TNat(),\n        branch2: TInt(),\n        branch3: TBytes()\n    },\n    // Optional argument (defaults to right combs)\n    ["branch1", ["branch2", "branch3"]]\n);\n')),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"./literals#variant"},"Value Example")))}d.isMDXComponent=!0}}]);